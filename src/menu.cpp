#include "menu.hpp"
#include <algorithm>
#include <iostream>

namespace fs = std::filesystem;

// Font bitmap 5x7 pour caracteres ASCII 32-127
// Chaque caractere est encode sur 5 bytes (colonnes)
static const uint8_t FONT_5X7[][5] = {
    {0x00, 0x00, 0x00, 0x00, 0x00}, // 32 (espace)
    {0x00, 0x00, 0x5F, 0x00, 0x00}, // 33 !
    {0x00, 0x07, 0x00, 0x07, 0x00}, // 34 "
    {0x14, 0x7F, 0x14, 0x7F, 0x14}, // 35 #
    {0x24, 0x2A, 0x7F, 0x2A, 0x12}, // 36 $
    {0x23, 0x13, 0x08, 0x64, 0x62}, // 37 %
    {0x36, 0x49, 0x55, 0x22, 0x50}, // 38 &
    {0x00, 0x05, 0x03, 0x00, 0x00}, // 39 '
    {0x00, 0x1C, 0x22, 0x41, 0x00}, // 40 (
    {0x00, 0x41, 0x22, 0x1C, 0x00}, // 41 )
    {0x08, 0x2A, 0x1C, 0x2A, 0x08}, // 42 *
    {0x08, 0x08, 0x3E, 0x08, 0x08}, // 43 +
    {0x00, 0x50, 0x30, 0x00, 0x00}, // 44 ,
    {0x08, 0x08, 0x08, 0x08, 0x08}, // 45 -
    {0x00, 0x60, 0x60, 0x00, 0x00}, // 46 .
    {0x20, 0x10, 0x08, 0x04, 0x02}, // 47 /
    {0x3E, 0x51, 0x49, 0x45, 0x3E}, // 48 0
    {0x00, 0x42, 0x7F, 0x40, 0x00}, // 49 1
    {0x42, 0x61, 0x51, 0x49, 0x46}, // 50 2
    {0x21, 0x41, 0x45, 0x4B, 0x31}, // 51 3
    {0x18, 0x14, 0x12, 0x7F, 0x10}, // 52 4
    {0x27, 0x45, 0x45, 0x45, 0x39}, // 53 5
    {0x3C, 0x4A, 0x49, 0x49, 0x30}, // 54 6
    {0x01, 0x71, 0x09, 0x05, 0x03}, // 55 7
    {0x36, 0x49, 0x49, 0x49, 0x36}, // 56 8
    {0x06, 0x49, 0x49, 0x29, 0x1E}, // 57 9
    {0x00, 0x36, 0x36, 0x00, 0x00}, // 58 :
    {0x00, 0x56, 0x36, 0x00, 0x00}, // 59 ;
    {0x00, 0x08, 0x14, 0x22, 0x41}, // 60 <
    {0x14, 0x14, 0x14, 0x14, 0x14}, // 61 =
    {0x41, 0x22, 0x14, 0x08, 0x00}, // 62 >
    {0x02, 0x01, 0x51, 0x09, 0x06}, // 63 ?
    {0x32, 0x49, 0x79, 0x41, 0x3E}, // 64 @
    {0x7E, 0x11, 0x11, 0x11, 0x7E}, // 65 A
    {0x7F, 0x49, 0x49, 0x49, 0x36}, // 66 B
    {0x3E, 0x41, 0x41, 0x41, 0x22}, // 67 C
    {0x7F, 0x41, 0x41, 0x22, 0x1C}, // 68 D
    {0x7F, 0x49, 0x49, 0x49, 0x41}, // 69 E
    {0x7F, 0x09, 0x09, 0x01, 0x01}, // 70 F
    {0x3E, 0x41, 0x41, 0x51, 0x32}, // 71 G
    {0x7F, 0x08, 0x08, 0x08, 0x7F}, // 72 H
    {0x00, 0x41, 0x7F, 0x41, 0x00}, // 73 I
    {0x20, 0x40, 0x41, 0x3F, 0x01}, // 74 J
    {0x7F, 0x08, 0x14, 0x22, 0x41}, // 75 K
    {0x7F, 0x40, 0x40, 0x40, 0x40}, // 76 L
    {0x7F, 0x02, 0x04, 0x02, 0x7F}, // 77 M
    {0x7F, 0x04, 0x08, 0x10, 0x7F}, // 78 N
    {0x3E, 0x41, 0x41, 0x41, 0x3E}, // 79 O
    {0x7F, 0x09, 0x09, 0x09, 0x06}, // 80 P
    {0x3E, 0x41, 0x51, 0x21, 0x5E}, // 81 Q
    {0x7F, 0x09, 0x19, 0x29, 0x46}, // 82 R
    {0x46, 0x49, 0x49, 0x49, 0x31}, // 83 S
    {0x01, 0x01, 0x7F, 0x01, 0x01}, // 84 T
    {0x3F, 0x40, 0x40, 0x40, 0x3F}, // 85 U
    {0x1F, 0x20, 0x40, 0x20, 0x1F}, // 86 V
    {0x7F, 0x20, 0x18, 0x20, 0x7F}, // 87 W
    {0x63, 0x14, 0x08, 0x14, 0x63}, // 88 X
    {0x03, 0x04, 0x78, 0x04, 0x03}, // 89 Y
    {0x61, 0x51, 0x49, 0x45, 0x43}, // 90 Z
    {0x00, 0x00, 0x7F, 0x41, 0x41}, // 91 [
    {0x02, 0x04, 0x08, 0x10, 0x20}, // 92 backslash
    {0x41, 0x41, 0x7F, 0x00, 0x00}, // 93 ]
    {0x04, 0x02, 0x01, 0x02, 0x04}, // 94 ^
    {0x40, 0x40, 0x40, 0x40, 0x40}, // 95 _
    {0x00, 0x01, 0x02, 0x04, 0x00}, // 96 `
    {0x20, 0x54, 0x54, 0x54, 0x78}, // 97 a
    {0x7F, 0x48, 0x44, 0x44, 0x38}, // 98 b
    {0x38, 0x44, 0x44, 0x44, 0x20}, // 99 c
    {0x38, 0x44, 0x44, 0x48, 0x7F}, // 100 d
    {0x38, 0x54, 0x54, 0x54, 0x18}, // 101 e
    {0x08, 0x7E, 0x09, 0x01, 0x02}, // 102 f
    {0x08, 0x14, 0x54, 0x54, 0x3C}, // 103 g
    {0x7F, 0x08, 0x04, 0x04, 0x78}, // 104 h
    {0x00, 0x44, 0x7D, 0x40, 0x00}, // 105 i
    {0x20, 0x40, 0x44, 0x3D, 0x00}, // 106 j
    {0x00, 0x7F, 0x10, 0x28, 0x44}, // 107 k
    {0x00, 0x41, 0x7F, 0x40, 0x00}, // 108 l
    {0x7C, 0x04, 0x18, 0x04, 0x78}, // 109 m
    {0x7C, 0x08, 0x04, 0x04, 0x78}, // 110 n
    {0x38, 0x44, 0x44, 0x44, 0x38}, // 111 o
    {0x7C, 0x14, 0x14, 0x14, 0x08}, // 112 p
    {0x08, 0x14, 0x14, 0x18, 0x7C}, // 113 q
    {0x7C, 0x08, 0x04, 0x04, 0x08}, // 114 r
    {0x48, 0x54, 0x54, 0x54, 0x20}, // 115 s
    {0x04, 0x3F, 0x44, 0x40, 0x20}, // 116 t
    {0x3C, 0x40, 0x40, 0x20, 0x7C}, // 117 u
    {0x1C, 0x20, 0x40, 0x20, 0x1C}, // 118 v
    {0x3C, 0x40, 0x30, 0x40, 0x3C}, // 119 w
    {0x44, 0x28, 0x10, 0x28, 0x44}, // 120 x
    {0x0C, 0x50, 0x50, 0x50, 0x3C}, // 121 y
    {0x44, 0x64, 0x54, 0x4C, 0x44}, // 122 z
};

Menu::Menu() {}

bool Menu::init(SDL_Renderer *renderer) {
  (void)renderer;
  return true;
}

void Menu::scanRoms(const std::string &directory) {
  romFiles.clear();

  try {
    for (const auto &entry : fs::directory_iterator(directory)) {
      if (entry.is_regular_file()) {
        std::string ext = entry.path().extension().string();
        std::transform(ext.begin(), ext.end(), ext.begin(), ::tolower);
        if (ext == ".ch8" || ext == ".c8" || ext == ".rom") {
          romFiles.push_back(entry.path().string());
        }
      }
    }
    std::sort(romFiles.begin(), romFiles.end());
  } catch (const std::exception &e) {
    std::cerr << "Erreur scan ROMs: " << e.what() << std::endl;
  }
}

void Menu::drawText(SDL_Renderer *renderer, const std::string &text, int x,
                    int y, bool selected) {
  int scale = 2;
  int charWidth = 6 * scale;
  int charHeight = 8 * scale;

  SDL_Color color =
      selected ? SDL_Color{255, 255, 0, 255} : SDL_Color{180, 180, 180, 255};
  SDL_SetRenderDrawColor(renderer, color.r, color.g, color.b, color.a);

  for (size_t i = 0; i < text.length(); ++i) {
    char c = text[i];
    if (c < 32 || c > 122)
      c = '?';
    int idx = c - 32;

    if (idx >= 0 && idx < 91) {
      for (int col = 0; col < 5; ++col) {
        uint8_t colData = FONT_5X7[idx][col];
        for (int row = 0; row < 7; ++row) {
          if (colData & (1 << row)) {
            SDL_Rect pixel = {x + static_cast<int>(i) * charWidth + col * scale,
                              y + row * scale, scale, scale};
            SDL_RenderFillRect(renderer, &pixel);
          }
        }
      }
    }
  }
}

void Menu::render(SDL_Renderer *renderer) {
  SDL_SetRenderDrawColor(renderer, 15, 15, 30, 255);
  SDL_RenderClear(renderer);

  // Titre
  drawText(renderer, "CHIP-8 ROM SELECTOR", 180, 20, false);

  // Liste des ROMs
  int startY = 60;
  int itemHeight = 22;
  int visibleItems = 10;

  int startIndex = std::max(0, selectedIndex - visibleItems / 2);
  int endIndex =
      std::min(static_cast<int>(romFiles.size()), startIndex + visibleItems);

  for (int i = startIndex; i < endIndex; ++i) {
    std::string name = fs::path(romFiles[i]).stem().string();
    bool isSelected = (i == selectedIndex);

    int yPos = startY + (i - startIndex) * itemHeight;

    if (isSelected) {
      SDL_SetRenderDrawColor(renderer, 40, 40, 80, 255);
      SDL_Rect bgRect = {30, yPos - 3, 580, itemHeight};
      SDL_RenderFillRect(renderer, &bgRect);

      // Fleche
      drawText(renderer, ">", 35, yPos, true);
    }

    drawText(renderer, name, 60, yPos, isSelected);
  }

  // Instructions
  drawText(renderer, "UP/DOWN: Navigate   ENTER: Select   ESC: Quit", 80, 290,
           false);

  SDL_RenderPresent(renderer);
}

int Menu::run(SDL_Renderer *renderer) {
  if (romFiles.empty()) {
    std::cerr << "Aucune ROM trouvee" << std::endl;
    return -1;
  }

  SDL_Event event;
  bool running = true;

  while (running) {
    while (SDL_PollEvent(&event)) {
      if (event.type == SDL_QUIT) {
        return -1;
      }
      if (event.type == SDL_KEYDOWN) {
        switch (event.key.keysym.sym) {
        case SDLK_UP:
          selectedIndex =
              (selectedIndex - 1 + romFiles.size()) % romFiles.size();
          break;
        case SDLK_DOWN:
          selectedIndex = (selectedIndex + 1) % romFiles.size();
          break;
        case SDLK_RETURN:
        case SDLK_KP_ENTER:
          return selectedIndex;
        case SDLK_ESCAPE:
          return -1;
        }
      }
    }

    render(renderer);
    SDL_Delay(16);
  }

  return -1;
}

const std::string &Menu::getSelectedRom() const {
  return romFiles[selectedIndex];
}
